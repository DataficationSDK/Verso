@inject INotebookService Service
@inject IJSRuntime JS

<div class="verso-cell @(IsSelected ? "verso-cell--selected" : "") @(IsExecuting ? "verso-cell--executing" : "") @(IsInPreviewMode ? "verso-cell--preview" : "")">
    <div class="verso-cell-gutter">
        <span class="verso-cell-index">[@(Index + 1)]</span>
    </div>

    <div class="verso-cell-content">
        <div class="verso-cell-toolbar">
            <div class="verso-cell-type-dropdown" @onfocusout="OnTypeDropdownFocusOut" tabindex="-1">
                <button class="verso-cell-type-badge" @onclick="ToggleTypeDropdown">
                    @CellData.Type
                    <span class="verso-cell-type-chevron">&#9662;</span>
                </button>
                @if (_showTypeDropdown)
                {
                    <div class="verso-cell-type-popup">
                        @foreach (var ct in Service.AvailableCellTypes)
                        {
                            var t = ct;
                            var isActive = string.Equals(t.Id, CellData.Type, StringComparison.OrdinalIgnoreCase);
                            <button class="verso-cell-type-option @(isActive ? "verso-cell-type-option--active" : "")"
                                    @onclick="() => SelectCellType(t.Id)">
                                @t.DisplayName
                            </button>
                        }
                    </div>
                }
            </div>
            @if (CellData.Type == "code" && CellData.Language is not null)
            {
                <span class="verso-cell-language">@CellData.Language</span>
            }
            <div class="verso-cell-toolbar-actions">
                @foreach (var action in _enabledCellActions)
                {
                    var act = action;
                    <button class="verso-cell-btn verso-cell-btn--action"
                            @onclick="() => ExecuteCellActionAsync(act)"
                            title="Export @act.DisplayName">
                        @if (act.Icon is not null)
                        {
                            @((MarkupString)act.Icon)
                        }
                        else
                        {
                            @act.DisplayName
                        }
                    </button>
                }
                @if (Index > 0)
                {
                    <button class="verso-cell-btn" @onclick="() => OnMoveUp.InvokeAsync(CellData.Id)" title="Move Up">&#x25B2;</button>
                }
                @if (!IsLast)
                {
                    <button class="verso-cell-btn" @onclick="() => OnMoveDown.InvokeAsync(CellData.Id)" title="Move Down">&#x25BC;</button>
                }
                <button class="verso-cell-btn verso-cell-btn--run" @onclick="() => OnRunCell.InvokeAsync(CellData.Id)" title="Run" disabled="@IsExecuting">
                    @if (IsExecuting) { <span class="verso-spinner"></span> } else { <span>&#x25B6;</span> }
                </button>
                <button class="verso-cell-btn verso-cell-btn--delete" @onclick="() => OnDeleteCell.InvokeAsync(CellData.Id)" title="Delete">&#x2715;</button>
            </div>
        </div>

        @if (!IsInPreviewMode)
        {
            <div class="verso-cell-editor" @onclick="() => OnSelect.InvokeAsync(CellData.Id)">
                <MonacoEditor Value="@CellData.Source"
                              Language="@EditorLanguage"
                              OnValueChanged="HandleSourceChanged"
                              OnEditorAction="HandleEditorAction"
                              OnGetHoverInfo="HandleGetHoverInfo"
                              OnGetCompletions="HandleGetCompletions" />
            </div>
        }

        @if (CellData.Outputs.Count > 0)
        {
            <div class="verso-cell-outputs @(IsInPreviewMode ? "verso-cell-outputs--clickable" : "")"
                 @onclick="HandleOutputClick">
                @foreach (var output in CellData.Outputs)
                {
                    @if (output.IsError)
                    {
                        <div class="verso-output verso-output--error">
                            <div class="verso-output-error-name">@(output.ErrorName ?? "Error")</div>
                            <pre class="verso-output-error-content">@output.Content</pre>
                            @if (output.ErrorStackTrace is not null)
                            {
                                <pre class="verso-output-error-stack">@output.ErrorStackTrace</pre>
                            }
                        </div>
                    }
                    else if (output.MimeType == "text/html" || output.MimeType == "image/svg+xml")
                    {
                        <div class="verso-output verso-output--html">
                            @((MarkupString)output.Content)
                        </div>
                    }
                    else
                    {
                        <div class="verso-output verso-output--text">
                            <pre>@output.Content</pre>
                        </div>
                    }
                }
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public CellModel CellData { get; set; } = default!;
    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public bool IsExecuting { get; set; }
    [Parameter] public int Index { get; set; }
    [Parameter] public bool IsLast { get; set; }
    [Parameter] public EventCallback<Guid> OnRunCell { get; set; }
    [Parameter] public EventCallback<Guid> OnDeleteCell { get; set; }
    [Parameter] public EventCallback<Guid> OnSelect { get; set; }
    [Parameter] public EventCallback<Guid> OnMoveUp { get; set; }
    [Parameter] public EventCallback<Guid> OnMoveDown { get; set; }
    [Parameter] public EventCallback<(Guid CellId, string Source)> OnSourceChanged { get; set; }
    [Parameter] public EventCallback<(Guid CellId, string Action)> OnCellAction { get; set; }
    [Parameter] public EventCallback<(Guid CellId, string NewType)> OnCellTypeChanged { get; set; }
    [Parameter] public bool CollapsesInput { get; set; }

    private List<ToolbarActionInfo> _enabledCellActions = new();
    private bool _showTypeDropdown;

    // Actions already represented by hardcoded buttons in the cell toolbar
    private static readonly HashSet<string> _hardcodedActionIds = new(StringComparer.OrdinalIgnoreCase)
    {
        "verso.action.run-cell"
    };

    private bool IsInPreviewMode => CollapsesInput && CellData.Outputs.Count > 0 && !IsSelected;

    private string EditorLanguage => CellData.Type == "markdown" ? "markdown" : (CellData.Language ?? "csharp");

    protected override async Task OnParametersSetAsync()
    {
        if (!Service.IsLoaded)
        {
            _enabledCellActions = new();
            return;
        }

        var cellActions = Service.GetToolbarActions(ToolbarPlacement.CellToolbar)
            .Where(a => !_hardcodedActionIds.Contains(a.ActionId))
            .ToList();

        if (cellActions.Count == 0)
        {
            _enabledCellActions = new();
            return;
        }

        var enabledStates = await Service.GetActionEnabledStatesAsync(
            ToolbarPlacement.CellToolbar,
            new List<Guid> { CellData.Id });

        _enabledCellActions = cellActions
            .Where(a => enabledStates.GetValueOrDefault(a.ActionId, false)
                        && !_hardcodedActionIds.Contains(a.ActionId))
            .ToList();
    }

    private async Task ExecuteCellActionAsync(ToolbarActionInfo action)
    {
        await Service.ExecuteActionAsync(action.ActionId, new List<Guid> { CellData.Id });
    }

    private async Task HandleEditorAction(string action)
    {
        await OnCellAction.InvokeAsync((CellData.Id, action));
    }

    private async Task HandleSourceChanged(string newSource)
    {
        await OnSourceChanged.InvokeAsync((CellData.Id, newSource));
    }

    private async Task HandleOutputClick()
    {
        if (IsInPreviewMode)
        {
            await OnSelect.InvokeAsync(CellData.Id);
        }
    }

    private async Task<object?> HandleGetHoverInfo(string code, int position)
    {
        var info = await Service.GetHoverInfoAsync(CellData.Id, code, position);
        if (info is null) return null;

        if (info.Range is { } r)
            return new { content = info.Content, range = new { startLine = r.StartLine, startColumn = r.StartColumn, endLine = r.EndLine, endColumn = r.EndColumn } };

        return new { content = info.Content };
    }

    private async Task<object?> HandleGetCompletions(string code, int position)
    {
        var completions = await Service.GetCompletionsAsync(CellData.Id, code, position);
        if (completions is null) return null;

        return new
        {
            items = completions.Items.Select(c => new
            {
                displayText = c.DisplayText,
                insertText = c.InsertText,
                kind = c.Kind,
                description = c.Description,
                sortText = c.SortText
            }).ToArray()
        };
    }

    private void ToggleTypeDropdown()
    {
        _showTypeDropdown = !_showTypeDropdown;
    }

    private async Task OnTypeDropdownFocusOut()
    {
        await Task.Delay(150);
        _showTypeDropdown = false;
    }

    private async Task SelectCellType(string typeId)
    {
        _showTypeDropdown = false;
        if (!string.Equals(typeId, CellData.Type, StringComparison.OrdinalIgnoreCase))
            await OnCellTypeChanged.InvokeAsync((CellData.Id, typeId));
    }
}
