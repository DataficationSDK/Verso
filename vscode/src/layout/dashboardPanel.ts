import * as vscode from "vscode";
import { HostProcess } from "../host/hostProcess";
import {
  LayoutRenderResult,
  LayoutUpdateCellParams,
  LayoutSetEditModeParams,
  ExecutionRunParams,
} from "../host/protocol";

/**
 * Manages a VS Code WebviewPanel for rendering non-linear (dashboard) layouts.
 * The panel displays HTML generated by the engine's RenderLayoutAsync and handles
 * postMessage communication for cell execution, resize, drag-to-move, and edit operations.
 */
export class DashboardPanel implements vscode.Disposable {
  private panel: vscode.WebviewPanel | undefined;
  private readonly host: HostProcess;
  private readonly disposables: vscode.Disposable[] = [];

  constructor(host: HostProcess) {
    this.host = host;
  }

  /** Creates or reveals the dashboard webview panel. */
  async show(): Promise<void> {
    if (this.panel) {
      this.panel.reveal(vscode.ViewColumn.One);
      return;
    }

    this.panel = vscode.window.createWebviewPanel(
      "verso.dashboard",
      "Verso Dashboard",
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
      }
    );

    this.panel.onDidDispose(
      () => {
        this.panel = undefined;
      },
      null,
      this.disposables
    );

    this.panel.webview.onDidReceiveMessage(
      async (msg) => {
        await this.handleMessage(msg);
      },
      null,
      this.disposables
    );

    await this.refresh();
  }

  /** Requests fresh HTML from the host and updates the webview. */
  async refresh(): Promise<void> {
    if (!this.panel) return;

    try {
      const result = (await this.host.sendRequest(
        "layout/render"
      )) as LayoutRenderResult;
      this.update(result.html);
    } catch (err) {
      this.update(
        `<p style="color:red;">Failed to render dashboard: ${
          err instanceof Error ? err.message : err
        }</p>`
      );
    }
  }

  /** Sets the webview HTML content with embedded drag/resize interactivity. */
  update(html: string): void {
    if (!this.panel) return;

    this.panel.webview.html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; padding: 0; font-family: var(--vscode-font-family, sans-serif); font-size: var(--vscode-font-size, 13px); color: var(--vscode-foreground); background: var(--vscode-editor-background); }
    .verso-dashboard-grid { display: grid; grid-template-columns: repeat(12, 1fr); grid-auto-rows: 50px; gap: 8px; padding: 16px; align-content: start; min-height: 100vh; }
    .verso-dashboard-cell { position: relative; border: 1px solid var(--vscode-panel-border, #e0e0e0); border-radius: 6px; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 1px 3px rgba(0,0,0,0.08); transition: box-shadow 0.15s, border-color 0.15s; }
    .verso-dashboard-cell:hover { border-color: var(--vscode-focusBorder, #0078d4); box-shadow: 0 2px 8px rgba(0,0,0,0.12); }
    .verso-dashboard-cell-toolbar { display: flex; gap: 4px; padding: 4px 8px; border-bottom: 1px solid var(--vscode-panel-border, #e0e0e0); background: var(--vscode-sideBar-background, #252526); cursor: grab; flex-shrink: 0; opacity: 0; transition: opacity 0.15s; }
    .verso-dashboard-cell:hover .verso-dashboard-cell-toolbar { opacity: 1; }
    .verso-dashboard-cell-toolbar button { padding: 2px 8px; border: 1px solid var(--vscode-button-border, transparent); border-radius: 3px; background: var(--vscode-button-secondaryBackground, #3a3d41); color: var(--vscode-button-secondaryForeground, #ccc); cursor: pointer; font-size: 11px; }
    .verso-dashboard-cell-toolbar button:hover { background: var(--vscode-button-secondaryHoverBackground, #45494e); }
    .verso-dashboard-drag-icon { margin-left: auto; color: var(--vscode-descriptionForeground, #858585); font-size: 14px; cursor: grab; user-select: none; }
    .verso-dashboard-cell-output { flex: 1; overflow: auto; padding: 10px 12px; }
    .verso-dashboard-cell-output pre { margin: 0; white-space: pre-wrap; word-break: break-word; font-family: var(--vscode-editor-font-family, monospace); font-size: var(--vscode-editor-font-size, 13px); }
    .verso-dashboard-resize-handle { position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: se-resize; opacity: 0; transition: opacity 0.15s; z-index: 2; }
    .verso-dashboard-resize-handle::after { content: ''; position: absolute; bottom: 3px; right: 3px; width: 10px; height: 10px; border-right: 2px solid var(--vscode-descriptionForeground, #858585); border-bottom: 2px solid var(--vscode-descriptionForeground, #858585); }
    .verso-dashboard-cell:hover .verso-dashboard-resize-handle { opacity: 1; }
    .verso-dashboard-cell.verso-resizing { opacity: 0.7; z-index: 10; box-shadow: 0 4px 16px rgba(0,0,0,0.2); }
    .verso-dashboard-cell.verso-dragging { opacity: 0.3; }
    .verso-output--error { color: var(--vscode-errorForeground, #f44747); }
  </style>
</head>
<body>
  ${html}
  <script>
    const vscode = acquireVsCodeApi();

    // Button click handler
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-action]');
      if (!btn) return;
      const action = btn.dataset.action;
      const cellId = btn.dataset.cellId;
      if (action === 'run') {
        vscode.postMessage({ type: 'run', cellId });
      } else if (action === 'edit') {
        vscode.postMessage({ type: 'edit', cellId });
      }
    });

    // Grid metrics helper
    function getGridMetrics() {
      const grid = document.querySelector('.verso-dashboard-grid');
      if (!grid) return null;
      const style = window.getComputedStyle(grid);
      const gap = parseFloat(style.gap) || 8;
      const paddingLeft = parseFloat(style.paddingLeft) || 16;
      const paddingTop = parseFloat(style.paddingTop) || 16;
      const colWidth = (grid.clientWidth - paddingLeft * 2 + gap) / 12;
      const rowHeight = 50;
      return { grid, gap, paddingLeft, paddingTop, colWidth, rowHeight };
    }

    // Parse cell's current grid position from its style
    function getCellSpans(el) {
      const colMatch = el.style.gridColumn.match(/span\\s+(\\d+)/);
      const rowMatch = el.style.gridRow.match(/span\\s+(\\d+)/);
      return {
        colSpan: colMatch ? parseInt(colMatch[1]) : 6,
        rowSpan: rowMatch ? parseInt(rowMatch[1]) : 4
      };
    }

    // Initialize resize on all cells
    document.querySelectorAll('.verso-dashboard-resize-handle').forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();

        const cell = handle.closest('.verso-dashboard-cell');
        if (!cell) return;
        const cellId = cell.dataset.cellId;
        const m = getGridMetrics();
        if (!m) return;

        const startRect = cell.getBoundingClientRect();
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = startRect.width;
        const startHeight = startRect.height;

        const ghost = document.createElement('div');
        ghost.style.cssText = 'position:fixed;border:2px dashed #0078D4;border-radius:6px;background:rgba(0,120,212,0.05);pointer-events:none;z-index:1000;';
        ghost.style.left = startRect.left + 'px';
        ghost.style.top = startRect.top + 'px';
        ghost.style.width = startWidth + 'px';
        ghost.style.height = startHeight + 'px';
        document.body.appendChild(ghost);

        const label = document.createElement('div');
        label.style.cssText = 'position:fixed;background:#0078D4;color:white;padding:2px 8px;border-radius:3px;font-size:11px;font-family:monospace;pointer-events:none;z-index:1001;';
        document.body.appendChild(label);

        cell.classList.add('verso-resizing');

        function onMouseMove(ev) {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          const newWidth = Math.max(m.colWidth, startWidth + dx);
          const newHeight = Math.max(m.rowHeight, startHeight + dy);
          const snappedCols = Math.max(1, Math.min(12, Math.round(newWidth / m.colWidth)));
          const snappedRows = Math.max(1, Math.round(newHeight / (m.rowHeight + m.gap)));
          ghost.style.width = (snappedCols * m.colWidth - m.gap) + 'px';
          ghost.style.height = (snappedRows * (m.rowHeight + m.gap) - m.gap) + 'px';
          label.textContent = snappedCols + ' \\u00d7 ' + snappedRows;
          label.style.left = (startRect.left + parseFloat(ghost.style.width) + 8) + 'px';
          label.style.top = (startRect.top + parseFloat(ghost.style.height) - 20) + 'px';
        }

        function onMouseUp(ev) {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          cell.classList.remove('verso-resizing');
          ghost.remove();
          label.remove();

          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          const newCols = Math.max(1, Math.min(12, Math.round(Math.max(m.colWidth, startWidth + dx) / m.colWidth)));
          const newRows = Math.max(1, Math.round(Math.max(m.rowHeight, startHeight + dy) / (m.rowHeight + m.gap)));

          // Get current row/col from style
          const colStart = parseInt(cell.style.gridColumn) - 1 || 0;
          const rowStart = parseInt(cell.style.gridRow) - 1 || 0;

          vscode.postMessage({ type: 'resize', cellId, row: rowStart, col: colStart, width: newCols, height: newRows });
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    });

    // Initialize drag-to-move on all cells
    document.querySelectorAll('.verso-dashboard-drag-handle').forEach(dragHandle => {
      dragHandle.addEventListener('mousedown', (e) => {
        if (e.target.closest('button')) return;
        e.preventDefault();
        e.stopPropagation();

        const cell = dragHandle.closest('.verso-dashboard-cell');
        if (!cell) return;
        const cellId = cell.dataset.cellId;
        const m = getGridMetrics();
        if (!m) return;

        const gridRect = m.grid.getBoundingClientRect();
        const startRect = cell.getBoundingClientRect();
        const startX = e.clientX;
        const startY = e.clientY;
        const spans = getCellSpans(cell);

        const ghost = cell.cloneNode(true);
        ghost.style.cssText = 'position:fixed;pointer-events:none;z-index:1000;opacity:0.7;width:' +
          startRect.width + 'px;height:' + startRect.height + 'px;' +
          'border:2px solid #0078D4;border-radius:6px;background:var(--vscode-editor-background,#1e1e1e);box-shadow:0 8px 24px rgba(0,0,0,0.3);';
        ghost.style.left = startRect.left + 'px';
        ghost.style.top = startRect.top + 'px';
        document.body.appendChild(ghost);

        const placeholder = document.createElement('div');
        placeholder.style.cssText = 'border:2px dashed #0078D4;border-radius:6px;background:rgba(0,120,212,0.08);pointer-events:none;';
        placeholder.style.gridColumn = cell.style.gridColumn;
        placeholder.style.gridRow = cell.style.gridRow;

        cell.classList.add('verso-dragging');
        m.grid.appendChild(placeholder);

        function onMouseMove(ev) {
          ghost.style.left = (startRect.left + ev.clientX - startX) + 'px';
          ghost.style.top = (startRect.top + ev.clientY - startY) + 'px';

          const cursorX = ev.clientX - gridRect.left - m.paddingLeft;
          const cursorY = ev.clientY - gridRect.top - m.paddingTop;
          const targetCol = Math.max(0, Math.min(12 - spans.colSpan, Math.floor(cursorX / m.colWidth)));
          const targetRow = Math.max(0, Math.floor(cursorY / (m.rowHeight + m.gap)));

          placeholder.style.gridColumn = (targetCol + 1) + ' / span ' + spans.colSpan;
          placeholder.style.gridRow = (targetRow + 1) + ' / span ' + spans.rowSpan;
        }

        function onMouseUp(ev) {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          cell.classList.remove('verso-dragging');
          ghost.remove();
          placeholder.remove();

          const cursorX = ev.clientX - gridRect.left - m.paddingLeft;
          const cursorY = ev.clientY - gridRect.top - m.paddingTop;
          const targetCol = Math.max(0, Math.min(12 - spans.colSpan, Math.floor(cursorX / m.colWidth)));
          const targetRow = Math.max(0, Math.floor(cursorY / (m.rowHeight + m.gap)));

          vscode.postMessage({ type: 'move', cellId, row: targetRow, col: targetCol, width: spans.colSpan, height: spans.rowSpan });
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    });
  </script>
</body>
</html>`;
  }

  /** Closes the dashboard panel if open. */
  close(): void {
    this.panel?.dispose();
    this.panel = undefined;
  }

  /** Returns true if the panel is currently visible. */
  get isVisible(): boolean {
    return this.panel?.visible ?? false;
  }

  dispose(): void {
    this.panel?.dispose();
    for (const d of this.disposables) {
      d.dispose();
    }
  }

  private async handleMessage(msg: {
    type: string;
    cellId?: string;
    width?: number;
    height?: number;
    row?: number;
    col?: number;
    editMode?: boolean;
  }): Promise<void> {
    switch (msg.type) {
      case "run":
        if (msg.cellId) {
          await this.host.sendRequest("execution/run", {
            cellId: msg.cellId,
          } as ExecutionRunParams);
          await this.refresh();
        }
        break;

      case "resize":
        if (msg.cellId) {
          await this.host.sendRequest("layout/updateCell", {
            cellId: msg.cellId,
            row: msg.row ?? 0,
            col: msg.col ?? 0,
            width: msg.width ?? 6,
            height: msg.height ?? 4,
          } as LayoutUpdateCellParams);
          await this.refresh();
        }
        break;

      case "move":
        if (msg.cellId) {
          await this.host.sendRequest("layout/updateCell", {
            cellId: msg.cellId,
            row: msg.row ?? 0,
            col: msg.col ?? 0,
            width: msg.width ?? 6,
            height: msg.height ?? 4,
          } as LayoutUpdateCellParams);
          await this.refresh();
        }
        break;

      case "editMode":
        await this.host.sendRequest("layout/setEditMode", {
          editMode: msg.editMode ?? false,
        } as LayoutSetEditModeParams);
        break;

      case "edit":
        if (msg.cellId) {
          vscode.window.showInformationMessage(
            `Edit cell ${msg.cellId} in the notebook view.`
          );
        }
        break;
    }
  }
}
